# vector （可变长数组）

vector（向量）: 是一种序列式容器，事实上和数组差不多，但它比数组更优越。一般来说数组不能动态拓展，因此在程序运行的时候不是浪费内存，就是造成越界。而 vector 正好弥补了这个缺陷，它的特征是相当于可拓展的数组（动态数组），它的随机访问快，在中间插入和删除慢，但在末端插入和删除快。

**特点**

* 拥有一段连续的内存空间，并且起始地址不变，因此它能非常好的支持随机存取，即 [] 操作符，但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝，另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。这些都大大影响了 vector 的效率。
* 对头部和中间进行插入删除元素操作需要移动内存，如果你的元素是结构或类，那么移动的同时还会进行构造和析构操作，所以性能不高。
* 对最后元素操作最快（在后面插入删除元素最快），此时一般不需要移动内存，只有保留内存不够时才需要。

**优缺点和适用场景**

* 优点：支持随机访问，即 [] 操作和 .at()，所以查询效率高。



* 缺点：当向其头部或中部插入或删除元素时，为了保持原本的相对次序，插入或删除点之后的所有元素都必须移动，所以插入的效率比较低。


* 适用场景：适用于对象简单，变化较小，并且频繁随机访问的场景。（一般来说，可以将任何使用C++内置数组的程序换成vector）  

**语法以及常用函数** 

* 头文件：`#include<vector>`  
* 一维向量的声明及初始化：  
    * 一般初始化：
        ```CPP
        vector<int> a; //定义了一个名为a的一维数组,数组存储int类型数据
        vector<double> b;//定义了一个名为b的一维数组，数组存储double类型数据
        vector<node> c;//定义了一个名为c的一维数组，数组存储结构体类型数据，node是结构体类型
        ```
    * 指定长度和初始值的初始化： 
        ```CPP
        vector<int> v(n);// 定义一个长度为n的数组，初始值默认为0，下标范围[0, n - 1]
        vector<int> v(n, 1);// v[0] 到 v[n - 1]所有的元素初始值均为1
        //注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了）

        ```
    * 初始化中有多个元素:
        ```CPP
        vector<int> a{1, 2, 3, 4, 5};//数组a中有五个元素，数组长度就为5
        ```

    * 拷贝初始化
        ```CPP
        vector<int> a(n + 1, 0);
        vector<int> b(a); // 两个数组中的类型必须相同,a和b都是长度为n+1，初始值都为0的数组
        vector<int> c = a; // 也是拷贝初始化,c和a是完全一样的数组
        ```
* 二维初始化：
```CPP
//初始化二维均可变长数组
vector<vector<int>> v;//定义一个行和列均可变的二维数组

vector<int> t1{1, 2, 3, 4};
vector<int> t2{2, 3, 4, 5};
v.push_back(t1);
v.push_back(t2);
v.push_back({3, 4, 5, 6}) // {3, 4, 5, 6}可以作为vector的初始化,相当于一个无名vector

```
* 方法函数（所谓方法函数就是他的用法一般是： 对象名称+ '.' + 方法名称 ，例如str为一个string的对象，他有个方法可以获取size长度，那么该方法的用法是`str.size()`）
知道了如何定义初始化可变数组，下面就需要知道如何添加，删除，修改数据。
c指定为数组名称，含义中会注明算法复杂度。      

    |  代码   | 含义  |
    |  ----  | ----  |
    |  c.front() | 返回第一个数据O（1） |
    |  c.back() | 返回数组中的最后一个数据|
    |  c.pop_back() | 删除最后一个数据|
    |  c.push_back(element) | 返回实际数据个数（unsigned类型）|
    | c.resize(n, v) | 改变数组大小为n,n个空间数值赋为v，如果没有默认赋值为0|
    |  c.insert(it, x) | 向任意迭代器it插入一个元素x 例：c.insert(c.begin() + 2,-1)，将-1插入c[2]的位置|
    |  c.erase(first,last) | 删除[first,last)的所有元素|
    |  c.begin()| 返回首元素的迭代器（通俗来说就是地址）|
    | c.end() | 返回最后一个元素后一个位置的迭代器（地址）|
    |  c.empty() | 判断是否为空，为空返回真，反之返回假|

    **注意：** end()返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，所有STL容器均是如此
* 排序：  
    使用sort排序要： `sort(c.begin(), c.end());`sort()为STL函数，请参考后面STL函数系列
    ```CPP
    vector<int> a(n + 1);
    sort(a.begin() + 1, a.end()); // 对[1, n]区间进行从小到大排序
    ```
* 访问：   
    * 下标法 ： 和普通数组一样
    注意：一维数组的下标是从 0 到 v.size()-1 ，访问之外的数会出现越界错误
    ```CPP
    //添加元素
    for(int i = 0; i < 5; i++)
        vi.push_back(i);
        
    //下标访问 
    for(int i = 0; i < 5; i++)
        cout << vi[i] << " ";
    cout << "\n";

    ```
    * 迭代器法 ： 类似指针一样的访问 ，首先需要声明迭代器变量，和声明指针变量一样，可以根据代码进行理解（附有注释）。
    ```CPP
    vector<int> vi{1, 2, 3, 4, 5};
    //迭代器访问
    vector<int>::iterator it;   
    // 相当于声明了一个迭代器类型的变量it
    // 通俗来说就是声明了一个指针变量
    vector<int>::iterator it = vi.begin();  //关键在于这里如何获取迭代器
    for(int i = 0; i < 5; i++)
        cout << *(it + i) << " ";
    cout << "\n";

    ```
    或者使用迭代器遍历： 类比数组中的i 
    ```CPP
    vector<int>::iterator it;
    for(it = vi.begin(); it != vi.end();it ++)
        cout << *it << " ";
    //vi.end()指向尾元素地址的下一个地址
  