# 贪心算法
贪心算法，又名贪婪法，是寻找最优解问题的常用方法，这种方法模式一般将求解过程分成若干个步骤，但每个步骤都应用贪心原则，选取当前状态下最好/最优的选择（局部最有利的选择），并以此希望最后堆叠出的结果也是最好/最优的解。{看着这个名字，贪心，贪婪这两字的内在含义最为关键。这就好像一个贪婪的人，他事事都想要眼前看到最好的那个，看不到长远的东西，也不为最终的结果和将来着想，贪图眼前局部的利益最大化，有点走一步看一步的感觉。}

* 贪婪法的基本步骤：

* 步骤1：从某个初始解出发；
* 步骤2：采用迭代的过程，当可以向目标前进一步时，就根据局部最优策略，得到一部分解，缩小问题规模；
* 步骤3：将所有解综合起来。

## 均分纸牌(Noip2002)
* 题目链接：
* 题目描述： 有n堆纸牌，编号分别为 1，2，…,n。每堆上有若干张，但纸牌总数必为n的倍数。可以在任一堆上取若干张纸牌，然后移动。  
移牌规则为：在编号为1的堆上取的纸牌，只能移到编号为 2的堆上；在编号为 n的堆上取的纸牌，只能移到编号为n−1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。  
现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。  
例如 n=4，4堆纸牌数分别为：  ①　9　②　8　③　17　④　6    
移动3次可达到目的：     
从 ③ 取4张牌放到④（9 8 13 10）->从③取3张牌放到 ②（9 11 10 10）-> 从②取1张牌放到①（10 10 10 10）。
* 输入描述：n（n堆纸牌，1≤n≤100）a1a2…an（n堆纸牌，每堆纸牌初始数，l≤ai≤10000）。
* 输出描述：所有堆均达到相等时的最少移动次数。

* 输入样例：
4  
9 8 17 6   
* 输出样例：3 

* 题目解析： 这是一道经典的贪心算法入门题目，要想用最少的移动次数把所有牌堆都移到相等，正确的贪心策略显然是：每次都移动尽可能多的纸牌。   
以正常人的思维来想，肯定是从纸牌数最多的牌堆开始往旁边的牌堆移动纸牌，但是如果要程序中模拟这个过程无疑是比较困难的。因为是计算机处理的缘故，我们可以移动负数张纸牌，且最后达到的效果一样。   
一开始先求出牌数的平均值，然后从第1堆开始遍历到第n-1堆牌，如果堆中的牌数不等于平均值，就移动堆中的牌数与平均值的差值张牌（这里无论正负）。接着，下一堆接收到移动过来的牌后，如果牌数不等于平均值，就移动差值张牌…如此循环反复，计算移动次数即可。
* 代码解析：   
```cpp
#include <iostream>
#include<vector>
using namespace std;
int main()
{
    int n;
    int ans=0,sum=0,t=0;//ans表示移动次数，t表示要移动的牌数
    cin>>n;
    vector<int> a(n);
    for(int i=0;i<n;i++)//输入数据
    {
        cin>>a[i];
        sum+=a[i];
    }
    int avg=sum/n;//求平均值
    for(int i=0;i<n-1;i++)//遍历每个牌堆（到最后一堆牌数一定等于平均值）
    {
        if(a[i]+t!=avg)//如果这个牌堆收到移动过来的牌后牌数不等于平均值，就需要移动
        {
            t=a[i]+t-avg;//计算移动的牌数，或正或负。
            ans++;//移动移动次数加一
        }
        else
        {
            t=0;//不用移动就是移动0张且次数不变
        }

    }
    cout<<ans<<endl;
    return 0;
}
```
