# 搜索算法深度优先搜索广度优先搜索

搜索算法：搜索算法就是指从图/树的某个节点开始，通过边到达不同的节点，最终找到目标结点的过程，根据搜索的策略不同，可以分为深度优先搜索（Depth-First Search）和广度优先搜索（Breadth-First Search）。所以在学习DFS和BFS之前，应该学习图和树的基本概念。  
树：一对多的结构  
图：多对多的结构

深度优先搜索采取“一条道走到黑的搜索方式”。这种搜索方式有两种实现方式：递归和非递归的形式。非递归的形式采用栈的方式来实现。由于该类算法实际上属于暴力解法，所以时间复杂度一般较高。通常需要采取剪枝等策略减少搜索次数提高效率。  
广度优先搜索实际上使用的是队列，每次将与当前节点相邻的节点入队。采取一种辐射状的搜索方式。   
## 深度优先搜索的模版
* 递归模版1
![alt text](images/moban.png)
* 递归模版2 
![alt text](images/moban2.png)
## 迷宫步数
* 题目描述： 有一个5行4列的方格迷营，0表示可以通过，1表示不可以通过，每一步可以向上、下、左、右任意方向移动一步，请计算从左上角 （1,1） 位置移动到右下角 （5,4） 位置，最少移动多少步。目前的打算是用将近一节半课的时间把深度优先搜索讲完，然后带着同学们做一下往年鹏程杯的习题，熟悉一下鹏程杯的难度和题型，再复习一下易错点。最后根据同学们的反馈看看是否需要加课。
* 迷宫图：![alt text](images/image.png)

* 代码示例： 
```cpp
#include<iostream>
using namespace std;
int dx[4] = {1, 0, -1, 0}; // 四个方向的行偏移量
int dy[4] = {0, -1, 0, 1}; //四个方向的列偏移量
int n, m, ans, a[15][15];   
bool vis[15][15];  //vis数组记录了小格子的访问状态
void dfs(int x, int y, int step)  //step表示到达当前点的步数
{ 
    if(x == n && y == m){      //到达右下角的话结束
        ans =min(ans, step);  //更新最短路径 
        return;
    }
    int tx, ty;
    for(int i =0; i< 4;++i){  //探索四个方向
        tx = x +dx[i];
        ty = y +dy[i];
        if(tx >=1 && tx <=n &&ty >=1 && ty <=m){  //探索的格子在矩阵内
            if(!vis[tx][ty] && a[tx][ty] == 0){  // 小格子未走过且可以走
                vis[tx][ty] = true;    //将当前格子标记过走过
                dfs(tx, ty, step +1);  //探索该方向
                vis[tx][ty] = false;   //回溯的时候恢复该点的原始状态
            }
        }
    }
}
int main()
{
    cin >> n >>m;
    for(int i = 1;i <=n;i++)
    {
        for(int j = 1; j <=m;++j)
            cin >> a[i][j];
    }
    ans = 0x3f3f3f; // 找最小值，初始为一个极大值
    vis[1][1]=true; //标记为已访问
    dfs(1, 1, 0); //调用函数 
    cout << ans;
    return 0;
}
```
## 数的划分
* 题目描述：将正整数划分为k份，每份不能为空，不考虑数的顺序，请计算出多少种不同的分法。
* 例如： ![alt text](images/image1.png)
* 样例输入： 8 3 
* 样例输出： 5 
* 算法分析：如果说我们保证每次划分的数都大于等于前面的数，这样可以做到不重复不漏。例如：
![alt text](images/image2.png)
这题可以转换成：
有k个位置，每个位置上的数都大于等于它前面的数，所有位置上的数的总和为n的方案数。  
可以给 dfs 函数加一个参数 start，表示当前位置可以放的最小的数  
另外，再增加一个参数 sum 表示当前位置之前所有位置上的数的和  
u表示当前位置的编号  
void dfs(int u, int start, int sum)
{

}
* 示例代码：
```cpp
#include<iostream>
using namespace std;
int n, k, ans;
void dfs(intint start， int sum)
{
    if（u==k+1）// 已分完k份
    {
        if（sum==n）//n 已全部分完
        {
            ans ++;
        }
        return ;
    }
    for(int i =start;i <= n;++i)//没分完， 继续分  如何优化for(ini i =0; i<= (n-sum)/(k-u+1);++i)
    {
        dfs(u +1 , i, sum+i);
    }
}
int main()
{
    cin >> n >> k;
    dfs(1, 1, 0);
    cout << ans;
    return 0;
}
```

## 岛屿问题
这类问题通常用0和1组成的二维矩阵表示一张地图，用1表示陆地用0表示水，通常让你用来计算岛屿的个数，最大面积，周长等问题，常常用深度优先搜索解决。
1. 岛屿数量（leetcode 200）
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。   
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。   
此外，你可以假设该网格的四条边均被水包围。   
* 输入格式： 第一行 m, n 表示 矩阵的行数和列数（整数）
下面m行每行n个数表示陆地还是岛屿（char）
* 输出格式： 一个数字表示统计的岛屿数目
* 输入样例： 
4 5 
1 1 1 1 0  
1 1 0 1 0  
1 1 0 0 0  
0 0 0 0 0  
* 输出样例：
1   
* 输入样例：
4 5  
1 1 0 0 0 
1 1 0 0 0   
0 0 1 0 0 
0 0 0 1 1   
* 输出样例：
3    

* 示例代码：
```
```
2. 岛屿的最大面积（leetcode 695）
给你一个大小为 m x n 的二进制矩阵 grid 。  

岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。  

岛屿的面积是岛上值为 1 的单元格的数目。  

计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。   
* 示例1. ![岛屿最大面积](./images/maxareaisland.jpg)
* 输入：
8 13 
0 0 1 0 0 0 0 1 0 0 0 0 0   
0 0 0 0 0 0 0 1 1 1 0 0 0  
0 1 1 0 1 0 0 0 0 0 0 0 0  
0 1 0 0 1 1 0 0 1 0 1 0 0  
0 1 0 0 1 1 0 0 1 1 1 0 0  
0 0 0 0 0 0 0 0 0 0 1 0 0  
0 0 0 0 0 0 0 1 1 1 0 0 0  
0 0 0 0 0 0 0 1 1 0 0 0 0  
* 输出样例： 
输出：6
解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。


3. 岛屿周长（leetcode 463）
给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。  

网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。   

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。   

* 示例1. ![岛屿周长](./images/islandlength.png)  
输入：
4 4 (表示行数和列数)
0 1 0 0  
1 1 1 0  
0 1 0 0  
1 1 0 0  
输出：16    
解释：它的周长是上面图片中的 16 个黄色的边  

* 示例输入2： 
1 1 
1 
* 示例输出2：
4

* 示例输入3： 
1 2 
1 0

* 示例输出3：
4 

* 代码示例：

## 排列，组合，子集问题
这类问题往往会给定一组待选取的数，称为candidates，要求得出特定的数字组合，目的是组成一个目标数或者得出不重复顺序的数，有时可以重复，有时不能重复。
这类问题通常由深度优先搜索解决，也就是回溯法。往往涉及到剪枝等DFS的高级操作。
解题步骤：先画图， 再解码。
对应的Leetcode习题：46，47，39，40，77，78，90，60，93
1. 全排列（leetcode46）
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。   
* 输入样例1： 
3  
1 2 3 
输入说明：第一行的数字说明数组中数的个数，第二行表示数组中的数
* 输出样例1： 
1 2 3   
1 3 2  
2 1 3  
2 3 1   
3 1 2    
3 2 1   
* 输入样例2：
2  
0 1 
* 输出样例2:
0 1  
1 0  
* 输入样例3：
1  
1   
* 输出样例3：
1  


2. 组合总和（leetcode 39 https://leetcode.cn/problems/combination-sum/description/）
给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。  
candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。    
对于给定的输入，保证和为 target 的不同组合数少于 150 个。  
* 示例输入1： 
4 7  
2 3 6 7  
输入解释： 4 表示给定candidates数组的长度，7表示target目标数，2 3 6 7 为candidate数组中每个数的元素
* 样例输出： 
2 2 3   
7  
输出解释： 
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。  
7 也是一个候选， 7 = 7 。  
仅有这两种组合。   

* 样例输入2： 
3 8  
2 3 5 
* 样例输出2：   
2 2 2 2    
2 3 3 
3 5   

* 样例输入3： 
1 1  
2   
* 样例输出3：
   
没有满足条件的组合所以为空。  


* 示例代码：


